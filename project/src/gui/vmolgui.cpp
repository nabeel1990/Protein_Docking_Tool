// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include "vmolgui.h"
#include "glwindow.h"
#include "../command/vmolcommand.h"



using namespace std;

VmolGui* VmolGui::singleInstance_=NULL;



VmolGui::VmolGui()
{
	init();
}

VmolGui::~VmolGui()
{
	init();
}

void VmolGui::init()
{
	mainWindow = NULL;
//	for (int i=0; i<NUM_OPENGL_BOXES; i++)
//		oglBox_[i] = NULL;
	oglBox_.clear();
/*
	tabMenu_ = NULL;
	tabDisplay_ = NULL;
	tabOptions_ = NULL;
	tabInfo_ = NULL;
	tabPDT_ = NULL;
*/

	tabList_.clear();
	groupList_.clear();

	optionsNumConsoleLines_ = 0;

	oglBoxSetting_ = 0;

	proteinCopySet_ = false;
}

void VmolGui::changeBoxNumber(int setting)
{
	int maxWidth=0, maxHeight=0;

	oglBoxSetting_ = setting;

	maxWidth = windowPosition_.width - tabMenuPosition_.width;
	maxHeight = windowPosition_.height - 60 - commandInputPosition_.height;

	if (setting == 0)
	{
		return;
	}
	else
	{
		int boxesPerRowInt=0, boxesPerColumnInt=0, currentBox=0;
		int boxWidth=0, boxHeight=0;
		float boxesPerRowFloat=0.0f;
		ControlPosition newBoxPosition;

		oglBox_.clear();
		oglBoxPosition_.clear();

		boxesPerRowFloat = sqrt(setting);
		boxesPerRowInt = (int) boxesPerRowFloat;

		if (boxesPerRowInt < boxesPerRowFloat)
			boxesPerRowInt += 1;

		boxesPerColumnInt = (int) setting/boxesPerRowInt;
		if (setting%boxesPerRowInt > 0)
			boxesPerColumnInt += 1;

		boxWidth = maxWidth / boxesPerRowInt;
		boxHeight = maxHeight / boxesPerColumnInt;

		currentBox = 0;
		for (int i=0; i<boxesPerRowInt; i++)
		{
			for (int j=0; j<boxesPerColumnInt; j++)
			{
				newBoxPosition.x = i * boxWidth + 1;
				newBoxPosition.y = j * boxHeight + 1 + 30;
				newBoxPosition.width = boxWidth - 1;
				newBoxPosition.height = boxHeight - 1;

				oglBoxPosition_.push_back(newBoxPosition);

//				oglBox_.push_back(
				currentBox += 1;
			}
		}
	}

/*
	if (setting == 1)
	{
//		oglBoxPosition_[0].x = 0;	oglBoxPosition_[0].y = 30;	oglBoxPosition_[0].width = 915;	oglBoxPosition_[0].height = 800;
		oglBoxPosition_[0].x = 0;
		oglBoxPosition_[0].y = 30;
		oglBoxPosition_[0].width = maxWidth;
		oglBoxPosition_[0].height = maxHeight;
	}
	else if (setting == 2)
	{
		oglBoxPosition_[0].x = 0;
		oglBoxPosition_[0].y = 30;
		oglBoxPosition_[0].width = maxWidth / 2 - 1;
		oglBoxPosition_[0].height = maxHeight / 2 - 1;

		oglBoxPosition_[1].x = maxWidth / 2 + 1;
		oglBoxPosition_[1].y = 30;
		oglBoxPosition_[1].width = maxWidth / 2 - 2;
		oglBoxPosition_[1].height = maxHeight / 2 - 2;

		oglBoxPosition_[2].x = 0;
		oglBoxPosition_[2].y = maxHeight / 2 + 31;
		oglBoxPosition_[2].width = maxWidth / 2 - 2;
		oglBoxPosition_[2].height = maxHeight / 2 - 2;

		oglBoxPosition_[3].x = maxWidth / 2 + 1;
		oglBoxPosition_[3].y = maxHeight / 2 + 31;
		oglBoxPosition_[3].width = maxWidth / 2 - 2;
		oglBoxPosition_[3].height = maxHeight / 2 - 2;
	}
*/

}

void VmolGui::changeBoxNumberAndResize(int setting)
{
	for (unsigned int i=0; i<oglBoxSetting_; i++)
		oglBox_[i]->hide();

	changeBoxNumber(setting);

	for (unsigned int i=0; i<setting; i++)
	{
		oglBox_[i]->resize(oglBoxPosition_[i].x, oglBoxPosition_[i].y, oglBoxPosition_[i].width, oglBoxPosition_[i].height);
//		getOglBox()[i]->resizeGL(getOglBoxPosition()[i].width, getOglBoxPosition()[i].height);
//		getOglBox()[i]->flush();
//		mainWindow->flush();
//		mainWindow->end();
		oglBox_[i]->show();
	}
}



vector<ControlPosition>& VmolGui::getOglBoxPosition()
{
	return oglBoxPosition_;
}

void VmolGui::setControlPositions()
{
	windowPosition_.x = 0;		windowPosition_.y = 0;		windowPosition_.width = 1280;	windowPosition_.height = 960;

	tabMenuPosition_.x = windowPosition_.width - 350;	tabMenuPosition_.y = 30;	tabMenuPosition_.width = 350;	tabMenuPosition_.height = windowPosition_.height - 50;

	commandInputPosition_.x = 80;	commandInputPosition_.y = windowPosition_.height - 50;	commandInputPosition_.width = windowPosition_.width - tabMenuPosition_.width - 80;	commandInputPosition_.height = 25;
//	commandInputPosition_.y = 50;

	changeBoxNumber(1);

//			tabMenu_ = new Fl_Tabs(915, 30, 250, 800);
}

void VmolGui::drawOpenGLBoxes()
{
//	if (oglBoxSetting_ == 1)
//		oglBox_[0]->redraw();
//	else if (oglBoxSetting_ == 2)
//	{
	for (int i=0; i<oglBoxSetting_; i++)
	{
//		printf ("%d\n", i);
		oglBox_[i]->redraw();
	}

//	}
}

void VmolGui::drawViews(vector<VmolView *> &viewList)
{
	for (unsigned int i=0; i<viewList.size(); i++)
	{
		viewList[i]->redraw();

		handleViewMouse(viewList[i]);
	}
}

int VmolGui::handleViewMouse(VmolView *view)
{
	if (view->getMouseDown() == true)
	{
		double moveX=0.0f, moveY=0.0f;

		moveX = (view->getMouseCurrentPosition().x - view->getMouseDownPosition().x) * view->getMouseSensitivityX();
		moveY = (view->getMouseCurrentPosition().y - view->getMouseDownPosition().y) * view->getMouseSensitivityY();

//		printf ("currentX =\t%d\n", view->getMouseCurrentPosition().x);
//		printf ("downX =\t%d\n", view->getMouseDownPosition().x);

		if (view->getMouseDownButton()>=1 && view->getMouseDownButton()<=3)
		{
			int downIndex=0;

			downIndex = (view->getMouseDownButton()-1)*6;

			if (view->isKeyDown(view->getShortcut1()) == true)
			{
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+2], view->getMouseEventBinds().variableType[downIndex+2], 0.0f, moveX, 0.0f, 0.0f);
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+3], view->getMouseEventBinds().variableType[downIndex+3], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+2], view->getMouseEventBinds().variableType[downIndex+2], moveX, 0.0f, 0.0f, 0.0f);
				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+3], view->getMouseEventBinds().variableType[downIndex+3], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+2], view->getMouseEventBinds().variableType[downIndex+2], 0.0f, 0.0f, moveX, 0.0f);
				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+3], view->getMouseEventBinds().variableType[downIndex+3], 0.0f, 0.0f, -moveY, 0.0f);
			}
			else if (view->isKeyDown(view->getShortcut2()) == true)
			{
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+2], view->getMouseEventBinds().variableType[downIndex+4], 0.0f, moveX, 0.0f, 0.0f);
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+3], view->getMouseEventBinds().variableType[downIndex+5], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+4], view->getMouseEventBinds().variableType[downIndex+4], moveX, 0.0f, 0.0f, 0.0f);
				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+5], view->getMouseEventBinds().variableType[downIndex+5], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+4], view->getMouseEventBinds().variableType[downIndex+4], 0.0f, 0.0f, 0.0f, moveX);
				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+5], view->getMouseEventBinds().variableType[downIndex+5], 0.0f, 0.0f, 0.0f, -moveY);
			}
			else
			{
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+0], view->getMouseEventBinds().variableType[downIndex+0], 0.0f, moveX, 0.0f, 0.0f);
//				handleViewMouseChangeVariable(view->getMouseEventBinds().variable[downIndex+1], view->getMouseEventBinds().variableType[downIndex+1], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+0], view->getMouseEventBinds().variableType[downIndex+0], moveX, 0.0f, 0.0f, 0.0f);
				handleViewMouseChangeScalarVariable(view->getMouseEventBinds().variable[downIndex+1], view->getMouseEventBinds().variableType[downIndex+1], -moveY, 0.0f, 0.0f, 0.0f);

				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+0], view->getMouseEventBinds().variableType[downIndex+0], moveX, 0.0f, 0.0f, 0.0f);
				handleViewMouseChangeVectorVariable(view->getMouseEventBinds().variable[downIndex+1], view->getMouseEventBinds().variableType[downIndex+1], 0.0f, -moveY, 0.0f, 0.0f);

//				OVDJE SAM STAO!!!
				// sto napraviti s ovim moveX i moveY?
				// trebali bi biti tako predani funkciji da moze univerzalno raditi za bilo koliko dimenzionalne varijable
//				RJESENJE!!!
				// ovaj problem mogu rijesiti ovako:
				// funkciju za handlanje mijenjanja varijabli misem rascijepam na dva dijela: skalarni i vektorski
				// (to je ok opcija, jer postoji mogucnost da se kasnije dodaju novi vektorski tipovi podataka)
				// onda za svaki if gore naveden pozovem jednom funkciju za skalarne varijable s parametrom moveY na prvom mjestu, odnosno na drugom mjestu za vektorske varijable
				// prema tome moveX bi bio uvijek na prvom mjestu
				// u slucaju prve tipke, trebalo bi jos razraditi, jer sad idem spavati...
			}
		}

		view->setMouseDownPosition(view->getMouseCurrentPosition());

//		printf ("moveX = %.2lf\tmoveY = %.2lf\n", moveX, moveY);
	}

	if (view->getMouseUp() == true)
	{
	}

	return 0;
}

int VmolGui::handleViewMouseChangeScalarVariable(void *variable, unsigned long long int &variableType, double x, double y, double z, double w)
{
	if (variable == NULL)
		return 1;

	if (variableType == COMMAND_VAR_CHAR)
	{
		char *tempVariable;
		char newX=0;

		newX = (char) x;
		tempVariable = &(((VariableName<char> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_UNSIGNED_CHAR)
	{
		unsigned char *tempVariable;
		unsigned char newX=0;

		newX = (unsigned char) x;
		tempVariable = &(((VariableName<unsigned char> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_LONG_INT)
	{
		long int *tempVariable;
		long int newX=0;

		newX = (long int) x;
		tempVariable = &(((VariableName<long int> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_UNSIGNED_LONG)
	{
		unsigned long int *tempVariable;
		unsigned long int newX=0;

		newX = (unsigned long int) x;
		tempVariable = &(((VariableName<unsigned long int> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_UNSIGNED_LONG_LONG)
	{
		unsigned long long int *tempVariable;
		unsigned long long int newX=0;

		newX = (unsigned long long int) x;
		tempVariable = &(((VariableName<unsigned long long int> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_FLOAT)
	{
		float *tempVariable;
		float newX=0;

		newX = (float) x;
		tempVariable = &(((VariableName<float> *) variable)->value);
		*tempVariable = *tempVariable + newX;

		return 0;
	}
	else if (variableType == COMMAND_VAR_DOUBLE)
	{
		double *tempVariable;
		double newX=0;

		newX = (double) x;
		tempVariable = &(((VariableName<double> *) variable)->value);
//		printf ("tempVariable1 = %.2lf\n", *tempVariable);
		*tempVariable = *tempVariable + newX;
//		printf ("tempVariable2 = %.2lf\n", *tempVariable);

		return 0;
	}

	return 2;
}

int VmolGui::handleViewMouseChangeVectorVariable(void *variable, unsigned long long int &variableType, double x, double y, double z, double w)
{
	if (variable == NULL)
		return 1;

	if (variableType == COMMAND_VAR_VECTOR3)
	{
		Vector3 *tempVariable;

		tempVariable = &(((VariableName<Vector3> *) variable)->value);
		tempVariable->x += x;
		tempVariable->y += y;
		tempVariable->z += z;

		return 0;
	}
	else if (variableType == COMMAND_VAR_COLOR)
	{
		Color *tempVariable;
		unsigned char newX=0, newY=0, newZ=0, newW=0;

		tempVariable = &(((VariableName<Color> *) variable)->value);

		newX = (unsigned char) x;
		newY = (unsigned char) y;
		newZ = (unsigned char) z;
		newW = (unsigned char) w;

		tempVariable->r += newX;
		tempVariable->g += newY;
		tempVariable->b += newZ;
		tempVariable->a += newW;

		return 0;
	}
	else if (variableType == COMMAND_VAR_EULER_VECTOR3)
	{
		EulerVector3 *tempVariable;

		tempVariable = &(((VariableName<EulerVector3> *) variable)->value);
		tempVariable->alpha += x;
		tempVariable->beta += y;
		tempVariable->gamma += z;

		return 0;
	}

	return 2;
}

bool VmolGui::createGui()
{
	setControlPositions();

//	{
		mainWindow = new Fl_Double_Window(windowPosition_.x, windowPosition_.y, windowPosition_.width, windowPosition_.height, "LongView");
		mainWindow->labeltype(FL_NORMAL_LABEL);
		mainWindow->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
//		vmolMainWindow->fullscreen();
//		vmolMainWindow->fullscreen_off(x, y, w, h);
//		mainWindow->

		{

			changeBoxNumber(NUM_OPENGL_BOXES);
//			printf ("width = %d\theight = %d\n", oglBoxPosition_[0].width, oglBoxPosition_[0].height);

			for (int i=0; i<oglBoxSetting_; i++)
			{
//				printf ("createGui %d\n", i);
//				oglBox_[i] = new VmolView(oglBoxPosition_[i].x, oglBoxPosition_[i].y, oglBoxPosition_[i].width, oglBoxPosition_[i].height);
//				oglBox_[i]->tooltip("Molecule display area.");
				VmolView *newFlGlWindow;
				newFlGlWindow = new VmolView(oglBoxPosition_[i].x, oglBoxPosition_[i].y, oglBoxPosition_[i].width, oglBoxPosition_[i].height);
//				newFlGlWindow->tooltip("Molecule display area.");
//					newFlGlWindow->initializeGL();
				newFlGlWindow->hide();
//				mainWindow->add_resizable(*newFlGlWindow);
				oglBox_.push_back(newFlGlWindow);
			}

			changeBoxNumberAndResize(0);



/*
      oglBox1->box(FL_DOWN_BOX);
      oglBox1->color((Fl_Color)FL_BACKGROUND_COLOR);
      oglBox1->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
      oglBox1->labeltype(FL_NORMAL_LABEL);
      oglBox1->labelfont(0);
      oglBox1->labelsize(14);
      oglBox1->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
      oglBox1->align(FL_ALIGN_CENTER);
      oglBox1->when(FL_WHEN_RELEASE);
*/
		} // Fl_Gl_Window* oglBox1

		setupTabs();
		setupMenus();

		CommandInputTextBox *commandInput=NULL;
		commandInput = new CommandInputTextBox(commandInputPosition_.x, commandInputPosition_.y, commandInputPosition_.width, commandInputPosition_.height,"Command");

		Fl::visual(FL_DOUBLE|FL_RGB);
		mainWindow->show();
		mainWindow->end();
		mainWindow->resizable(mainWindow);

//	} // Fl_Double_Window* vmolMainWindow

/*
	mainWindow->begin();
	mainWindow->hide();
	printf ("oglBoxSetting_ = %d\n", oglBoxSetting_);
	for (int i=0; i<oglBoxSetting_; i++)
	{
		printf ("createGui %d\n", i);
//				oglBox_[i] = new VmolView(oglBoxPosition_[i].x, oglBoxPosition_[i].y, oglBoxPosition_[i].width, oglBoxPosition_[i].height);
//				oglBox_[i]->tooltip("Molecule display area.");
		VmolView *newFlGlWindow;
		newFlGlWindow = new VmolView(oglBoxPosition_[i].x, oglBoxPosition_[i].y, oglBoxPosition_[i].width, oglBoxPosition_[i].height);
		newFlGlWindow->tooltip("Molecule display area.");
		oglBox_.push_back(newFlGlWindow);

// ovdje isprobavam kako naknadno dodati kontrole

		mainWindow->add(newFlGlWindow);
	}
//	mainWindow->end();
	mainWindow->show();
	mainWindow->end();
*/

}

int VmolGui::getOglBoxSetting()
{
	return oglBoxSetting_;
}

VmolGui* VmolGui::getInstance()
{
	if (singleInstance_ == NULL)
	{
		singleInstance_ = new VmolGui();
		return singleInstance_;
	}

	return singleInstance_;
}

vector<VmolView *>& VmolGui::getOglBox()
{
	return oglBox_;
}

Fl_Choice* VmolGui::getOptionsView()
{
	return optionsView_;
}

unsigned long int VmolGui::getMacroStart()
{
	return macroStart_;
}

void VmolGui::setMacroStart(unsigned long int macroStart)
{
	macroStart_ = macroStart;
}

unsigned long int VmolGui::getMacroEnd()
{
	return macroEnd_;
}

void VmolGui::setMacroEnd(unsigned long int macroEnd)
{
	macroEnd_ = macroEnd;
}



void VmolGui::refreshGuiNodeTreeRecursion(VmolSceneNode *currentNode, std::string currentLocation)
{
	unsigned int i=0;

	if (currentLocation == "")
		currentLocation = currentNode->getName();
	else
		currentLocation = currentLocation + "/" + currentNode->getName();

//	printf ("currentLocation = %s\n", currentLocation.c_str());

	nodesNodeTree_->add(currentLocation.c_str());

	for (i=0; i<currentNode->getChildren().size(); i++)
	{
		refreshGuiNodeTreeRecursion(currentNode->getChildren()[i], currentLocation);
	}
}

void VmolGui::refreshGui()
{
	unsigned long int i=0, j=0;
	VmolCommand *command=NULL;

	command = VmolCommand::getInstance();

	if (pdtEvaluationPath_->value() == "")
		pdtEvaluationPath_->value("data/rmsd/default.rmsd");



/////////////////////////////////////////////
/////////// refresh varijabli ///////////////
/////////////////////////////////////////////
	int valuePdbActiveLigand=0, valuePdbActiveReceptor=0, valuePdbCorrectComplex=0;
	int valuePdbReceptorRotation=0, valuePdbLigandTranslation=0, valuePdbLigandRotation=0;

	int optionsMouseBindsValue=0, variablesScalarValue=0, variablesMeshValue=0;
	int variablesPdbValue=0, variablesMeshNodeModeValue=0, variablesPdbNodeModeValue=0, variablesPdbSphereMeshValue=0;
	int variablesPdbStickMeshValue=0, pdtActiveLigandValue=0, pdtActiveReceptorValue=0, pdtCorrectComplexValue=0;
	int pdtLigandRotationValue=0, pdtReceptorRotationValue=0, pdtLigandTranslationValue=0, nodesOptionsNodeModeValue=0;

	optionsMouseBindsValue = optionsMouseBinds_->value();
	variablesScalarValue = variablesScalar_->value();
	variablesMeshValue = variablesMesh_->value();
	variablesPdbValue = variablesPdb_->value();
	variablesMeshNodeModeValue = variablesMeshNodeMode_->value();
	variablesPdbNodeModeValue = variablesPdbNodeMode_->value();
	variablesPdbSphereMeshValue = variablesPdbSphereMesh_->value();
	variablesPdbStickMeshValue = variablesPdbStickMesh_->value();
	pdtActiveLigandValue = pdtActiveLigand_->value();
	pdtActiveReceptorValue = pdtActiveReceptor_->value();
	pdtCorrectComplexValue = pdtCorrectComplex_->value();
	pdtLigandRotationValue = pdtLigandRotation_->value();
	pdtReceptorRotationValue = pdtReceptorRotation_->value();
	pdtLigandTranslationValue = pdtLigandTranslation_->value();
	nodesOptionsNodeModeValue = nodesOptionsNodeMode_->value();

	optionsMouseBinds_->clear();
	variablesScalar_->clear();
	variablesMesh_->clear();
	variablesPdb_->clear();
	variablesMeshNodeMode_->clear();
	variablesPdbNodeMode_->clear();
	variablesPdbSphereMesh_->clear();
	variablesPdbStickMesh_->clear();
	pdtActiveLigand_->clear();
	pdtActiveReceptor_->clear();
	pdtCorrectComplex_->clear();
	pdtLigandRotation_->clear();
	pdtReceptorRotation_->clear();
	pdtLigandTranslation_->clear();
	nodesOptionsNodeMode_->clear();

	optionsMouseBinds_->add("(none)");
	variablesMeshNodeMode_->add("(unknown)");
	variablesPdbNodeMode_->add("(unknown)");
	variablesPdbSphereMesh_->add("(unknown)");
	variablesPdbStickMesh_->add("(unknown)");
	pdtActiveLigand_->add("(not selected)");
	pdtActiveReceptor_->add("(not selected)");
	pdtCorrectComplex_->add("(not selected)");
	pdtLigandRotation_->add("(not selected)");
	pdtReceptorRotation_->add("(not selected)");
	pdtLigandTranslation_->add("(not selected)");

	for (i=0; i<command->getCharList().size(); i++)
	{
		optionsMouseBinds_->add(command->getCharList()[i].name.c_str());
		variablesScalar_->add(command->getCharList()[i].name.c_str());
	}

	for (i=0; i<command->getUCharList().size(); i++)
	{
		optionsMouseBinds_->add(command->getUCharList()[i].name.c_str());
		variablesScalar_->add(command->getUCharList()[i].name.c_str());
	}

	for (i=0; i<command->getLongIntList().size(); i++)
	{
		optionsMouseBinds_->add(command->getLongIntList()[i].name.c_str());
		variablesScalar_->add(command->getLongIntList()[i].name.c_str());
	}

	for (i=0; i<command->getULongIntList().size(); i++)
	{
		optionsMouseBinds_->add(command->getULongIntList()[i].name.c_str());
		variablesScalar_->add(command->getULongIntList()[i].name.c_str());
	}

	for (i=0; i<command->getULongLongIntList().size(); i++)
	{
		optionsMouseBinds_->add(command->getULongLongIntList()[i].name.c_str());
		variablesScalar_->add(command->getULongLongIntList()[i].name.c_str());
		variablesMeshNodeMode_->add(command->getULongLongIntList()[i].name.c_str());
		variablesPdbNodeMode_->add(command->getULongLongIntList()[i].name.c_str());
		nodesOptionsNodeMode_->add(command->getULongLongIntList()[i].name.c_str());
	}

	for (i=0; i<command->getFloatList().size(); i++)
	{
		optionsMouseBinds_->add(command->getFloatList()[i].name.c_str());
		variablesScalar_->add(command->getFloatList()[i].name.c_str());
	}

	for (i=0; i<command->getDoubleList().size(); i++)
	{
		optionsMouseBinds_->add(command->getDoubleList()[i].name.c_str());
		variablesScalar_->add(command->getDoubleList()[i].name.c_str());
	}

	for (i=0; i<command->getVector3List().size(); i++)
	{
		optionsMouseBinds_->add(command->getVector3List()[i].name.c_str());
		variablesScalar_->add(command->getVector3List()[i].name.c_str());
		pdtLigandTranslation_->add(command->getVector3List()[i].name.c_str());

		if (command->getVector3List()[i].name == "translationLigand")
			valuePdbLigandTranslation = i + 1;
	}

	for (i=0; i<command->getColorList().size(); i++)
	{
		optionsMouseBinds_->add(command->getColorList()[i].name.c_str());
		variablesScalar_->add(command->getColorList()[i].name.c_str());
	}

	for (i=0; i<command->getEulerVector3List().size(); i++)
	{
		optionsMouseBinds_->add(command->getEulerVector3List()[i].name.c_str());
		variablesScalar_->add(command->getEulerVector3List()[i].name.c_str());
		pdtLigandRotation_->add(command->getEulerVector3List()[i].name.c_str());
		pdtReceptorRotation_->add(command->getEulerVector3List()[i].name.c_str());

		if (command->getEulerVector3List()[i].name == "rotationLigand")
			valuePdbLigandRotation = i + 1;
		if (command->getEulerVector3List()[i].name == "rotationReceptor")
			valuePdbReceptorRotation = i + 1;
	}

	for (i=0; i<command->getStringList().size(); i++)
	{
		optionsMouseBinds_->add(command->getStringList()[i].name.c_str());
		variablesScalar_->add(command->getStringList()[i].name.c_str());
	}

	for (i=0; i<command->getMeshList().size(); i++)
	{
		variablesMesh_->add(command->getMeshList()[i]->getName().c_str());
		variablesPdbSphereMesh_->add(command->getMeshList()[i]->getName().c_str());
		variablesPdbStickMesh_->add(command->getMeshList()[i]->getName().c_str());
	}

	for (i=0; i<command->getPdbList().size(); i++)
	{
		variablesPdb_->add(command->getPdbList()[i]->getName().c_str());

		pdtActiveLigand_->add(command->getPdbList()[i]->getName().c_str());
		if (command->getPdbList()[i]->getName() == "ligand")
			valuePdbActiveLigand = i + 1;

		pdtActiveReceptor_->add(command->getPdbList()[i]->getName().c_str());
		if (command->getPdbList()[i]->getName() == "receptor")
			valuePdbActiveReceptor = i + 1;

		pdtCorrectComplex_->add(command->getPdbList()[i]->getName().c_str());
		if (command->getPdbList()[i]->getName() == "complex")
			valuePdbCorrectComplex = i + 1;
	}










	if (optionsMouseBinds_->size() <= optionsMouseBindsValue)	optionsMouseBindsValue = optionsMouseBinds_->size() - 1;
	if (optionsMouseBindsValue < 0)	optionsMouseBindsValue = 0;
	if (variablesScalar_->size() < variablesScalarValue)	variablesScalarValue = variablesScalar_->size();
	if (variablesScalarValue < 0)	variablesScalarValue = 0;
	if (variablesMesh_->size() < variablesMeshValue)	variablesMeshValue = variablesMesh_->size();
	if (variablesMeshValue < 0)	variablesMeshValue = 0;
	if (variablesPdb_->size() < variablesPdbValue)	variablesPdbValue = variablesPdb_->size();
	if (variablesPdbValue < 0)	variablesPdbValue = 0;
	if (variablesMeshNodeMode_->size() <= variablesMeshNodeModeValue)	variablesMeshNodeModeValue = variablesMeshNodeMode_->size() - 1;
	if (variablesMeshNodeModeValue < 0)	variablesMeshNodeModeValue = 0;

	if (variablesPdbNodeMode_->size() <= variablesPdbNodeModeValue)	variablesPdbNodeModeValue = variablesPdbNodeMode_->size() - 1;
	if (variablesPdbNodeModeValue < 0)	variablesPdbNodeModeValue = 0;
	if (variablesPdbSphereMesh_->size() <= variablesPdbSphereMeshValue)	variablesPdbSphereMeshValue = variablesPdbSphereMesh_->size() - 1;
	if (variablesPdbSphereMeshValue < 0)	variablesPdbSphereMeshValue = 0;
	if (variablesPdbStickMesh_->size() <= variablesPdbStickMeshValue)	variablesPdbStickMeshValue = variablesPdbStickMesh_->size() - 1;
	if (variablesPdbStickMeshValue < 0)	variablesPdbStickMeshValue = 0;
	if (pdtActiveLigand_->size() <= pdtActiveLigandValue)	pdtActiveLigandValue = pdtActiveLigand_->size() - 1;
	if (pdtActiveLigandValue < 0)	pdtActiveLigandValue = 0;
	if (pdtActiveReceptor_->size() <= pdtActiveReceptorValue)	pdtActiveReceptorValue = pdtActiveReceptor_->size() - 1;
	if (pdtActiveReceptorValue < 0)	pdtActiveReceptorValue = 0;

	if (pdtCorrectComplex_->size() <= pdtCorrectComplexValue)	pdtCorrectComplexValue = pdtCorrectComplex_->size() - 1;
	if (pdtCorrectComplexValue < 0)	pdtCorrectComplexValue = 0;
	if (pdtLigandRotation_->size() <= pdtLigandRotationValue)	pdtLigandRotationValue = pdtLigandRotation_->size() - 1;
	if (pdtLigandRotationValue < 0)	pdtLigandRotationValue = 0;
	if (pdtReceptorRotation_->size() <= pdtReceptorRotationValue)	pdtReceptorRotationValue = pdtReceptorRotation_->size() - 1;
	if (pdtReceptorRotationValue < 0)	pdtReceptorRotationValue = 0;
	if (pdtLigandTranslation_->size() <= pdtLigandTranslationValue)	pdtLigandTranslationValue = pdtLigandTranslation_->size() - 1;
	if (pdtLigandTranslationValue < 0)	pdtLigandTranslationValue = 0;
	if (nodesOptionsNodeMode_->size() < nodesOptionsNodeModeValue)	nodesOptionsNodeModeValue = nodesOptionsNodeMode_->size();
	if (nodesOptionsNodeModeValue < 0)	nodesOptionsNodeModeValue = 0;

	if (pdtActiveLigandValue == 0)
		pdtActiveLigandValue = valuePdbActiveLigand;
	if (pdtActiveReceptorValue == 0)
		pdtActiveReceptorValue = valuePdbActiveReceptor;
	if (pdtCorrectComplexValue == 0)
		pdtCorrectComplexValue = valuePdbCorrectComplex;

	if (pdtReceptorRotationValue == 0)
		pdtReceptorRotationValue = valuePdbReceptorRotation;
	if (pdtLigandTranslationValue == 0)
		pdtLigandTranslationValue = valuePdbLigandTranslation;
	if (pdtLigandRotationValue == 0)
		pdtLigandRotationValue = valuePdbLigandRotation;

//	pdtActiveLigand_->value(valuePdbActiveLigand);
//	pdtActiveReceptor_->value(valuePdbActiveReceptor);
//	pdtCorrectComplex_->value(valuePdbCorrectComplex);
//	pdtLigandRotation_->value(0);
//	pdtReceptorRotation_->value(0);
//	pdtReceptorTranslation_->value(0);
//	nodesOptionsNodeMode_->value(0);
//	nodesOptionsNodeMode_->do_callback();

	optionsMouseBinds_->value(optionsMouseBindsValue);
	variablesScalar_->value(variablesScalarValue);
	variablesMesh_->value(variablesMeshValue);
	variablesPdb_->value(variablesPdbValue);
	variablesMeshNodeMode_->value(variablesMeshNodeModeValue);
	variablesPdbNodeMode_->value(variablesPdbNodeModeValue);
	variablesPdbSphereMesh_->value(variablesPdbSphereMeshValue);
	variablesPdbStickMesh_->value(variablesPdbStickMeshValue);
	pdtActiveLigand_->value(pdtActiveLigandValue);
	pdtActiveReceptor_->value(pdtActiveReceptorValue);
	pdtCorrectComplex_->value(pdtCorrectComplexValue);
	pdtLigandRotation_->value(pdtLigandRotationValue);
	pdtReceptorRotation_->value(pdtReceptorRotationValue);
	pdtLigandTranslation_->value(pdtLigandTranslationValue);
	nodesOptionsNodeMode_->value(nodesOptionsNodeModeValue);

	nodesOptionsNodeMode_->do_callback();



/////////////////////////////////////////////
/////////// refresh view-ova ////////////////
/////////////////////////////////////////////
	int viewValue=0, optionsViewValue=0;

	viewValue = displayViewList_->value();
	optionsViewValue = optionsView_->value();

//	printf ("viewValue = %d\n", viewValue);

	displayViewList_->clear();
	for (i=0; i<command->getViewList().size(); i++)
	{
		displayViewList_->add(command->getViewList()[i]->getName().c_str());
		optionsView_->add(command->getViewList()[i]->getName().c_str());
	}

	if (displayViewList_->size() < viewValue)	viewValue = displayViewList_->size();
	if (viewValue < 0)	viewValue = 0;

	if (optionsView_->size() < optionsViewValue)	optionsViewValue = optionsView_->size();
	if (optionsViewValue < 0)	optionsViewValue = 0;

//	printf ("viewValue = %d\n", viewValue);


//	printf ("viewValue = %d\n\n", viewValue);

	displayViewList_->value(viewValue);
	optionsView_->value(optionsViewValue);

/////////////////////////////////////////////
/////////// refresh node-ova ////////////////
/////////////////////////////////////////////
	int displayRootNodeValue=0, variablesMeshAssignNodeValue=0, variablesPdbAssignNodeValue=0, nodeTreeValue=0, nodesParentValue=0;

	displayRootNodeValue = displayRootNode_->value();
	variablesMeshAssignNodeValue = variablesMeshAssignNode_->value();
	variablesPdbAssignNodeValue = variablesPdbAssignNode_->value();
//	nodeTreeValue = nodesNodeTree_->
	nodesParentValue = nodesParent_->value();

	displayRootNode_->clear();
	variablesMeshAssignNode_->clear();
	variablesPdbAssignNode_->clear();
	nodesNodeTree_->clear();
	nodesParent_->clear();

	variablesMeshAssignNode_->add("(unknown)");
	variablesPdbAssignNode_->add("(unknown)");
	nodesParent_->add("(root)");

	for (i=0; i<command->getNodeList().size(); i++)
	{
		displayRootNode_->add(command->getNodeList()[i]->getName().c_str());
		variablesMeshAssignNode_->add(command->getNodeList()[i]->getName().c_str());
		variablesPdbAssignNode_->add(command->getNodeList()[i]->getName().c_str());
		nodesParent_->add(command->getNodeList()[i]->getName().c_str());
	}

	for (i=0; i<command->getRootNodes().size(); i++)
	{
		refreshGuiNodeTreeRecursion(command->getRootNodes()[i], ((string) ""));

//		for (j=0; j<command->getRootNodes()[i]->getChildren().size(); j++)
//		{
//			refreshGuiNodeTreeRecursion(command->getRootNodes()[i]->getChildren()[j], command->getRootNodes()[i]->getName());
//		}
	}

	nodesNodeTree_->redraw();

	if (displayRootNode_->size() <= displayRootNodeValue)	displayRootNodeValue = displayRootNode_->size() - 1;
	if (displayRootNodeValue < 0)	displayRootNodeValue = 0;

	if (variablesMeshAssignNode_->size() < variablesMeshAssignNodeValue)	variablesMeshAssignNodeValue = variablesMeshAssignNode_->size();
	if (variablesMeshAssignNodeValue < 0)	variablesMeshAssignNodeValue = 0;

	if (variablesPdbAssignNode_->size() < variablesPdbAssignNodeValue)	variablesPdbAssignNodeValue = variablesPdbAssignNode_->size();
	if (variablesPdbAssignNodeValue < 0)	variablesPdbAssignNodeValue = 0;

//	if (nodesNodeTree_->size() < nodesNodeTreeValue)	nodesNodeTreeValue = nodesNodeTree_->size();
//	if (nodesNodeTreeValue < 0)	nodesNodeTreeValue = 0;

	if (nodesParent_->size() < nodesParentValue)	nodesParentValue = nodesParent_->size();
	if (nodesParentValue < 0)	nodesParentValue = 0;

	displayRootNode_->value(displayRootNodeValue);
	variablesMeshAssignNode_->value(variablesMeshAssignNodeValue);
	variablesPdbAssignNode_->value(variablesPdbAssignNodeValue);
	nodesParent_->value(nodesParentValue);



/////////////////////////////////////////////
//////////// refresh konzole ////////////////
/////////////////////////////////////////////
	string newConsoleLine;

	if (optionsNumConsoleLines_ == 0)
		optionsConsoleTextBuffer_->text("");

	newConsoleLine = optionsConsoleTextBuffer_->text();
	optionsConsoleTextBuffer_->text("");

//	printf ("num = %d\n", optionsNumConsoleLines_);

	for (i=optionsNumConsoleLines_; i<Log::getInstance()->getLogLines().size(); i++)
	{
		newConsoleLine += "\n";
		newConsoleLine += Log::getInstance()->getLogLines()[i];
	}

	optionsConsoleTextBuffer_->text(newConsoleLine.c_str());
	optionsNumConsoleLines_ = Log::getInstance()->getLogLines().size();




/////////////////////////////////////////////
////////////// refresh misa /////////////////
/////////////////////////////////////////////
	if (VmolCommand::getInstance()->getViewList().size() > 0)
	{
		char tempChar[100];
		int optionIndex=0, optionView=0;
		unsigned long int retVariableType=0;
		void *variablePointer=NULL;
		string optionVariableName, tempString;

		optionIndex = optionsMouseButton_->value()*2;
		optionIndex += optionsMouseAction_->value();

		optionView = optionsView_->value();
		variablePointer = VmolCommand::getInstance()->getViewList()[optionView]->getMouseEventBinds().variable[optionIndex];
		optionVariableName = VmolCommand::getInstance()->findVariable(variablePointer, &retVariableType);
		if (optionVariableName == "")
			optionVariableName = "(none)";

		for (i=0; i<optionsMouseBinds_->size(); i++)
		{
			tempString = optionsMouseBinds_->text(i);

			if (tempString == optionVariableName)
			{
				optionsMouseBinds_->value(i);
				optionsMouseBinds_->set_changed();
				optionsMouseBinds_->redraw();
				break;
			}
		}



		sprintf (tempChar, "%c", VmolCommand::getInstance()->getViewList()[optionView]->getShortcut1());
		optionsShortcut1_->value(tempChar);
		sprintf (tempChar, "%c", VmolCommand::getInstance()->getViewList()[optionView]->getShortcut2());
		optionsShortcut2_->value(tempChar);
		sprintf (tempChar, "%.2lf", VmolCommand::getInstance()->getViewList()[optionView]->getMouseSensitivityX());
		optionsMouseSensitivityX_->value(tempChar);
		sprintf (tempChar, "%.2lf", VmolCommand::getInstance()->getViewList()[optionView]->getMouseSensitivityY());
		optionsMouseSensitivityY_->value(tempChar);
	}
}

void VmolGui::refreshScore()
{
	if (pdtAutomaticScoring_->value() == 1)
	{
		pdtScoreConformation_->do_callback();
	}
}
